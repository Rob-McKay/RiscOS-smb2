/* -*-  mode:c; c-default-style "bsd" tab-width:8; c-basic-offset:4; indent-tabs-mode:nil;  -*- */
/*
 * Copyright 2023 Rob McKay
 *
 * This file is part of 'RISC OS libsmb2'
 *
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2.1 of the License, or
 * (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "libsmb2Hdr.h"

#include <stdint.h>
#include <stddef.h>
#include <smb2/smb2.h>
#include <smb2/libsmb2.h>

#define SWI_OFFSET(x) ((SMB2_##x) - SMB2_00)

static _kernel_oserror *do_create_context(_kernel_swi_regs *regs)
{
    struct smb2_context *res = smb2_init_context();
    if (res != NULL)
    {
        regs->r[0] = (int)res;
        return NULL;
    }
    static _kernel_oserror err = {SMB2_00, "Cannot create context"};
    return &err;
}

static _kernel_oserror *do_destroy_context(_kernel_swi_regs *regs)
{
    smb2_destroy_context((struct smb2_context *)regs->r[0]);
    return NULL;
}

static _kernel_oserror *do_set_smb_version(_kernel_swi_regs *regs)
{
    smb2_set_version((struct smb2_context *)regs->r[0], (enum smb2_negotiate_version)regs->r[1]);
    return NULL;
}

static _kernel_oserror *do_set_security_mode(_kernel_swi_regs *regs)
{
    smb2_set_security_mode((struct smb2_context *)regs->r[0], regs->r[1]);
    return NULL;
}

static _kernel_oserror *do_set_seal(_kernel_swi_regs *regs)
{
    smb2_set_seal((struct smb2_context *)regs->r[0], regs->r[1]);
    return NULL;
}

static _kernel_oserror *do_set_signing(_kernel_swi_regs *regs)
{
    smb2_set_sign((struct smb2_context *)regs->r[0], regs->r[1]);
    return NULL;
}

static _kernel_oserror *do_set_user(_kernel_swi_regs *regs)
{
    smb2_set_user((struct smb2_context *)regs->r[0], (const char *)regs->r[1]);
    return NULL;
}

static _kernel_oserror *do_set_password(_kernel_swi_regs *regs)
{
    smb2_set_password((struct smb2_context *)regs->r[0], (const char *)regs->r[1]);
    return NULL;
}

static _kernel_oserror *do_set_domain(_kernel_swi_regs *regs)
{
    smb2_set_domain((struct smb2_context *)regs->r[0], (const char *)regs->r[1]);
    return NULL;
}

static _kernel_oserror *do_set_workstation(_kernel_swi_regs *regs)
{
    smb2_set_workstation((struct smb2_context *)regs->r[0], (const char *)regs->r[1]);
    return NULL;
}

static _kernel_oserror *do_connect_share(_kernel_swi_regs *regs)
{
    int result = smb2_connect_share((struct smb2_context *)regs->r[0], (const char *)regs->r[1], (const char *)regs->r[2], (const char *)regs->r[3]);
    if (result < 0)
    {
        static _kernel_oserror err = {SMB2_00, "Cannot connect to share"};
        return &err;
    }
    return NULL;
}

static _kernel_oserror *do_disconnect_share(_kernel_swi_regs *regs)
{
    int result = smb2_disconnect_share((struct smb2_context *)regs->r[0]);
    if (result < 0)
    {
        static _kernel_oserror err = {SMB2_00, "Cannot disconnect from share"};
        return &err;
    }

    return NULL;
}

static _kernel_oserror *do_share_enum(_kernel_swi_regs *regs) { return error_BAD_SWI; }

static _kernel_oserror *do_open_dir(_kernel_swi_regs *regs)
{
    struct smb2dir *result = smb2_opendir((struct smb2_context *)regs->r[0], (const char *)regs->r[1]);
    if (result != NULL)
    {
        regs->r[0] = (int)result;
        return NULL;
    }
    else
    {
        static _kernel_oserror err = {SMB2_00, "Cannot open directory"};
        return &err;
    }
}

static _kernel_oserror *do_close_dir(_kernel_swi_regs *regs)
{
    smb2_closedir((struct smb2_context *)regs->r[0], (struct smb2dir *)regs->r[1]);
    return NULL;
}

static _kernel_oserror *do_read_dir(_kernel_swi_regs *regs)
{
    struct smb2dirent *result = smb2_readdir((struct smb2_context *)regs->r[0], (struct smb2dir *)regs->r[1]);
    if (result != NULL)
    {
        regs->r[0] = (int)result;
        return NULL;
    }
    else
    {
        static _kernel_oserror err = {SMB2_00, "Cannot connect to share"};
        return &err;
    }
}

static _kernel_oserror *do_rewind_dir(_kernel_swi_regs *regs)
{
    smb2_rewinddir((struct smb2_context *)regs->r[0], (struct smb2dir *)regs->r[1]);
    return NULL;
}

static _kernel_oserror *do_tell_dir(_kernel_swi_regs *regs)
{
    long result = smb2_telldir((struct smb2_context *)regs->r[0], (struct smb2dir *)regs->r[1]);
    if (result != NULL)
    {
        regs->r[0] = (int)result;
        return NULL;
    }
    else
    {
        static _kernel_oserror err = {SMB2_00, "Cannot connect to share"};
        return &err;
    }
}

static _kernel_oserror *do_seek_dir(_kernel_swi_regs *regs)
{
    smb2_seekdir((struct smb2_context *)regs->r[0], (struct smb2dir *)regs->r[1], regs->r[2]);
    return NULL;
}

static _kernel_oserror *do_open(_kernel_swi_regs *regs)
{
    struct smb2fh *result = smb2_open((struct smb2_context *)regs->r[0], (char *)regs->r[1], regs->r[2]);
    if (result != NULL)
    {
        regs->r[0] = (int)result;
        return NULL;
    }
    else
    {
        static _kernel_oserror err = {SMB2_00, "Cannot open file"};
        return &err;
    }
}

static _kernel_oserror *do_close(_kernel_swi_regs *regs)
{
    int result = smb2_close((struct smb2_context *)regs->r[0], (struct smb2fh *)regs->r[1]);
    if (result == 0)
    {
        return NULL;
    }
    else
    {
        static _kernel_oserror err = {SMB2_00, "Cannot close file handle"};
        return &err;
    }
}

static _kernel_oserror *do_fsync(_kernel_swi_regs *regs)
{
    int result = smb2_fsync((struct smb2_context *)regs->r[0], (struct smb2fh *)regs->r[1]);
    if (result == 0)
    {
        regs->r[0] = (int)result;
        return NULL;
    }
    else
    {
        static _kernel_oserror err = {SMB2_00, "fsync failed"};
        return &err;
    }
}

static _kernel_oserror *do_get_max_read_size(_kernel_swi_regs *regs)
{
    uint32_t result = smb2_get_max_read_size((struct smb2_context *)regs->r[0]);
    regs->r[0] = (int)result;
    return NULL;
}

static _kernel_oserror *do_get_max_write_size(_kernel_swi_regs *regs)
{
    uint32_t result = smb2_get_max_write_size((struct smb2_context *)regs->r[0]);
    regs->r[0] = (int)result;
    return NULL;
}

static _kernel_oserror *do_pread(_kernel_swi_regs *regs)
{
    uint64_t offset = ((uint64_t)regs->r[4]) | (((uint64_t)(regs->r[5])) << 32);

    int result = smb2_pread((struct smb2_context *)regs->r[0], (struct smb2fh *)regs->r[1], (uint8_t *)regs->r[2], (uint32_t)regs->r[3], offset);
    if (result >= 0)
    {
        regs->r[0] = result;
        return NULL;
    }
    else
    {
        static _kernel_oserror err = {SMB2_00, "Failed to read data"};
        return &err;
    }
}

static _kernel_oserror *do_read(_kernel_swi_regs *regs)
{
    int result = smb2_read((struct smb2_context *)regs->r[0], (struct smb2fh *)regs->r[1], (uint8_t *)regs->r[2], (uint32_t)regs->r[3]);
    if (result >= 0)
    {
        regs->r[0] = result;
        return NULL;
    }
    else
    {
        static _kernel_oserror err = {SMB2_00, "Failed to read"};
        return &err;
    }
}

static _kernel_oserror *do_pwrite(_kernel_swi_regs *regs)
{
    uint64_t offset = ((uint64_t)regs->r[4]) | (((uint64_t)(regs->r[5])) << 32);

    int result = smb2_pwrite((struct smb2_context *)regs->r[0], (struct smb2fh *)regs->r[1], (uint8_t *)regs->r[2], (uint32_t)regs->r[3], offset);
    if (result >= 0)
    {
        regs->r[0] = result;
        return NULL;
    }
    else
    {
        static _kernel_oserror err = {SMB2_00, "Failed to write data"};
        return &err;
    }
}

static _kernel_oserror *do_write(_kernel_swi_regs *regs)
{
    int result = smb2_write((struct smb2_context *)regs->r[0], (struct smb2fh *)regs->r[1], (uint8_t *)regs->r[2], (uint32_t)regs->r[3]);
    if (result >= 0)
    {
        regs->r[0] = result;
        return NULL;
    }
    else
    {
        static _kernel_oserror err = {SMB2_00, "Failed to read"};
        return &err;
    }
}

_kernel_oserror *libsmb2_swi_handler(int swi_offset, _kernel_swi_regs *regs, void *pw)
{
    switch (swi_offset)
    {
    case SWI_OFFSET(CreateContext):
        return do_create_context(regs);

    case SWI_OFFSET(DestroyContext):
        return do_destroy_context(regs);

    case SWI_OFFSET(SetSMBVersion):
        return do_set_smb_version(regs);

    case SWI_OFFSET(SetSecurityMode):
        return do_set_security_mode(regs);

    case SWI_OFFSET(SetSeal):
        return do_set_seal(regs);

    case SWI_OFFSET(SetSigning):
        return do_set_signing(regs);

    case SWI_OFFSET(SetUser):
        return do_set_user(regs);

    case SWI_OFFSET(SetPassword):
        return do_set_password(regs);

    case SWI_OFFSET(SetDomain):
        return do_set_domain(regs);

    case SWI_OFFSET(SetWorkstation):
        return do_set_workstation(regs);

    case SWI_OFFSET(ConnectShare):
        return do_connect_share(regs);

    case SWI_OFFSET(DisconnectShare):
        return do_disconnect_share(regs);

    case SWI_OFFSET(ShareEnum):
        return do_share_enum(regs);

    case SWI_OFFSET(OpenDir):
        return do_open_dir(regs);

    case SWI_OFFSET(CloseDir):
        return do_close_dir(regs);

    case SWI_OFFSET(ReadDir):
        return do_read_dir(regs);

    case SWI_OFFSET(RewindDir):
        return do_rewind_dir(regs);

    case SWI_OFFSET(TellDir):
        return do_tell_dir(regs);

    case SWI_OFFSET(SeekDir):
        return do_seek_dir(regs);

    case SWI_OFFSET(Open):
        return do_open(regs);

    case SWI_OFFSET(Close):
        return do_close(regs);

    case SWI_OFFSET(FSync):
        return do_fsync(regs);

    case SWI_OFFSET(GetMaxReadSize):
        return do_get_max_read_size(regs);

    case SWI_OFFSET(GetMaxWriteSize):
        return do_get_max_write_size(regs);

    case SWI_OFFSET(PRead):
        return do_pread(regs);

    case SWI_OFFSET(Read):
        return do_read(regs);

    case SWI_OFFSET(PWrite):
        return do_pwrite(regs);

    case SWI_OFFSET(Write):
        return do_write(regs);

    default:
        return error_BAD_SWI;
    }
}
